# blockプログラミングメモ
## 最初の実装（ゴール）
1. HGRモードに切り替え、画面をクリアする。
2. HGRモードにキャラクタを表示する。

# その他メモ
プログラムで使用するメモリ領域（特にコードセグメント）に合わせて、apple2.loaderのパラメータを変更する必要がある。
具体的には次のとおり。2箇所のアドレスをメインプログラムのエントリポイントアドレスに書き換える。


対象ファイル:src/apple2.loader/loader.s


```
READ_PARAM:
                .byte   $04             ;PARAM_COUNT
READ_REF:       .byte   $00             ;REF_NUM
                .addr   $6000           ;DATA_BUFFER
                .word   $FFFF           ;REQUEST_COUNT
                .word   $0000           ;TRANS_COUNT
```


上記の;DATA_BUFFERで指定されているアドレス


```
        ; Go for it ...
        jmp     $6000

```


上記のjmpで指定されているアドレス

# ビットマップ描写アルゴリズム

## データ定義
- 書き込みたいVRAMX座標
- 書き込みたいVRAMY座標
- 描写したいビットマップの幅(width)
- 描写したいビットマップの高さ(height)

## アルゴリズム
1. 描写したいY座標をもとに、VRAMのアドレスをテーブルから取得する
2. 取得したVRAMアドレスのlowアドレスに対して描写したいX座標値を加えて最終的に書き込むアドレスを計算する
3. 描写したいビットマップデータのアドレスを取得する
4. ビットマップデータを取得する
5. 2.で計算したVRAMアドレスに4.の値を書き込む
6. 以降、描写したいビットマップデータの幅、高さすべてを書き込むまで1.から繰り返す

## 6502ブランチ命令一覧

6502 には、次の 8 の条件付きブランチ命令があります。  
  
* BCC (Branch if Carry Clear): キャリーフラグがクリアされている場合、指定されたアドレスに分岐します。  
* BCS (Branch if Carry Set): キャリーフラグがセットされている場合、指定されたアドレスに分岐します。  
* BEQ (Branch if Equal): ゼロフラグがセットされている場合、指定されたアドレスに分岐します。  
* BNE (Branch if Not Equal): ゼロフラグがクリアされている場合、指定されたアドレスに分岐します。  
* BPL (Branch if Positive): 負フラグがクリアされている場合、指定されたアドレスに分岐します。  
* BMI (Branch if Minus): 負フラグがセットされている場合、指定されたアドレスに分岐します.  
* BVC (Branch if Overflow Clear): オーバーフローフラグがクリアされている場合、指定されたアドレスに分岐します。  
* BVS (Branch if Overflow Set): オーバーフローフラグがセットされている場合、指定されたアドレスに分岐します。  

6502 には、次の 2 つの条件なしブランチ命令もあります。  

* JSR (Jump to Subroutine): 現在のプログラムカウンターをスタックにプッシュし、指定されたアドレスに分岐します。  
* RTS (Return from Subroutine): スタックからプログラムカウンターをポップし、そのアドレスに分岐します。  

## 6502 Pレジスタ
6502プロセッサーのPレジスタは、8ビットのステータスレジスタです。このレジスタは、CPUが実行中のプログラムの実行状態を保持し、プログラムの制御フローを制御するために使用されます。  

| ビット | 名称 | 解説|
|--------|------|-------------
| 7      | N    | 結果が負の場合にセットされます。 
| 6      | V    | オーバーフローが発生した場合にセットされます。
| 5      | -    | 未使用。
| 4      | B    | インタラプトフラグです。Bが1にセットされると、BRK命令によってCPUが割り込まれたことを示します。
| 3      | D    | デシマルモードです。Dが1にセットされると、ADCやSBC命令がBCD（10進数）モードで動作するようになります。
| 2      | I    | 割り込みフラグです。Iが1にセットされると、マスク可能な割り込みが無効化されます。
| 1      | Z    | 結果がゼロの場合にセットされます。
| 0      | C    | キャリーフラグです。結果が0から255の範囲外になる場合や、減算で借りが生じた場合にセットされます。また、シフト命令での桁あふれが生じた場合にもセットされます。

Pレジスタのビットは、CPU命令や割り込み処理中で自動的に変更されます。また、LDA、STA、PHP、PLPなどの命令を使用して、Pレジスタの値を明示的に読み書きすることもできます。Pレジスタは、CPUの動作に欠かせない重要なレジスタの1つです。  

6502プロセッサのcmp命令は、2つのオペランドを比較し、結果に応じてフラグを設定します。この命令は、比較結果が等しい場合にゼロフラグを設定し、比較結果が負の場合にネガティブフラグを設定します。また、比較結果が正の場合には、キャリーフラグを設定します。  

例えば、次のようなコードがある場合:  

LDA #$05  
CMP #$03  
このコードは、レジスタAに5をロードし、3と比較します。比較結果は正であるため、キャリーフラグが設定されます。  

ディスク ソフトウェアは、Ctrl+P に続いて 6 を押すと起動できます。これは、通常 Disk II コントローラが含まれているスロット 6 を指します。  

- ビットテスト
BIT 命令でビットテストを行えます。レジスタを破壊せずに値を読めるので VBLANK 待ちなどでたまに使われますが、使用頻度は低いです。  
BIT 命令は N, V, Z フラグを書き換えます:  
N: 対象の bit7  
V: 対象の bit6  
Z: A と対象を and した結果が 0 であるか  

- ビットシフト
ASL で左シフトができます(空いた部分には 0 が入る)。"Arithmetic Shift Left" です。  
LSR で右シフトができます(空いた部分には 0 が入る)。"Logical Shift Right" です。  
これらの命令は N, Z, C フラグを書き換えます:  
N: 結果の最上位ビット  
Z: 結果が 0 であるか  
C: はみ出たビット  

- ビットローテート
C フラグを含めた 9bit ローテートができます。  
ROL で左ローテートができます(左シフトを行い、空いた部分に C が入る)。"ROTATE Left" です。  
ROR で右ローテートができます(右シフトを行い、空いた部分に C が入る)。"ROTATE Right" です。  
これらの命令は N, Z, C フラグを書き換えます:  
N: 結果の最上位ビット  
Z: 結果が 0 であるか  
C: はみ出たビット  
シフトとローテートを組み合わせることで多倍長シフトができます。例えば、16bit 値 $0700 (リトルエンディアン)を 1 回右シフトするには:  
```
; 上位バイトを右シフト
lsr $0701 ; はみ出たビットが C に入る
; 下位バイトを C フラグ込みで右ローテート
ror $0700
```

# ブロック崩しアルゴリズム
## ボールの移動計算アルゴリズム
ボールの座標管理は２つの変数で管理している。8bit演算だけで実装できるため。  
- １つはVRAMアドレスのX座標で0〜39の値
- もう一つはアドレス内に描写するビットパターン(0〜3)

# ハイレゾグラフィックスメモ
ハイレゾグラフィックでX座標は7bit単位での描写になる。このためX座標方向にスムーズに描写する場合は  
複数のビットマップを準備する必要がある。具体的な例は次の通り。  
1100  
0110  
0011  

1バイト中7ビットでビットマップを表現するため、偶数バイトと奇数バイトで色が変わってしまう。対策として次の方法が考えられる。  
- 描写対象のVRAMビットシフトが奇数の場合、描写対象のビットマップデータをシフトする
- 描写対象のVRAMアドレスは必ず偶数アドレスから開始するようにする
- 奇数、偶数それぞれのビットマップデータを用意し、描写開始位置によって動的に選択する

壁は通り抜けられませんよ
https://taotao54321.hatenablog.com/entry/2017/04/09/151355

# 比較（条件文)
CMP, CPX, CPY 命令で A, X, Y レジスタと対象の比較ができます。指定レジスタから対象を(ボローなし)減算し、結果を捨ててフラグだけ更新していると考えるとわかりやすいかもしれません。これらの命令は N, Z, C フラグを書き換えます(V は変化なし):  
* N: 減算結果の最上位ビット
* Z: 減算結果が 0 であるか
* C: 減算で繰り下がりが発生したら 0, さもなくば 1
普通は Z, C フラグのみを用いて大小関係を判定します。例えば CMP 命令の場合:  
- Z == 0 ならば A == (対象)
- C == 1 ならば A >= (対象)
- C == 0 ならば A < (対象)

* バイナリー->10進数文字列変換ルーチン(for CASL2アセンブラ)
; 符号無しバイナリ→10進文字列
; 入力  GR0=値
;       GR1=5語のバッファ
; 出力  5語のバッファに文字列（右詰、左はスペース）
;       GR0とGR1は不定になる
;
BINDEC START
       PUSH  0,GR2
; バッファの初期化
       LAD   GR2,#0020   ; スペースの文字コード
       ST    GR2,0,GR1   ; バッファをスペースクリア
       ST    GR2,1,GR1
       ST    GR2,2,GR1
       ST    GR2,3,GR1
       LAD   GR2,4,GR1   ; GR2=最後の文字のアドレス
; 10で割った余りをストアしていく
LOOP   DS    0
       LAD   GR1,10      ; 10で割る
       CALL  DIVL        ; GR1=商、GR0=余り
       ADDL  GR0,='0'    ; 数字に変換
       ST    GR0,0,GR2   ; 変換した文字を格納
       LAD   GR2,-1,GR2  ; バッファのアドレス
       LD    GR0,GR1     ; 商を次回の被除数にする
       JNZ   LOOP        ; 0なら終わり
; 終わり。
       POP   GR2
       RET
       END

* 配列アクセス
配列アクセスには indexed (lda $0700,x など)または indirect (lda ($00),y など)アドレッシングモードを使うのが普通です。  

配列のベースアドレスが固定ならば indexed で書けます。配列コピーの例を示します:  

        ; $0300-$030F を $0400-$040F へコピー
        ; 擬似コード化すると:
        ;
        ; for(X = 0x10; X != 0; --X)
        ;   mem[0x0400 + X] = mem[0x0300 + X]

        ldx #$10
@loop:
        lda $0300,x
        sta $0400,x
        dex
        bne @loop


        ; ポインタ $00 が指す領域から $0400-$040F へ 0x10 バイトコピー
        ; 擬似コード化すると:
        ;
        ; ptr = mem[0x00] | (mem[0x01] << 8)
        ; for(Y = 0; Y != 0x10; ++Y)
        ;   mem[0x0400 + Y] = mem[ptr + Y]

        ldy #0
@loop:
        lda ($00),y
        sta $0400,y
        iny
        cpy #$10
        bne @loop

* 構造体アクセス
構造体アクセスには indirect アドレッシングモードがよく使われます。オブジェクトリストを構造体の配列で管理しているゲームでは大抵以下のようなコードが出てきます:  

; オブジェクト構造体が以下のようであるとする:
;
; struct Object{
;   U8 state;
;   U8 position_x;
;   U8 position_y;
;   U8 velocity_x;
;   U8 velocity_y;
; };
;
; ポインタ $00 がオブジェクト構造体の先頭を指しているとする。

ldy #0
lda ($00),y ; オブジェクト状態取得
...
iny
lda ($00),y ; オブジェクト座標x取得
iny
lda ($00),y ; オブジェクト座標y取得
...
iny
lda ($00),y ; オブジェクト速度x取得
iny
lda ($00),y ; オブジェクト速度y取得

* 定数乗除算
6502 には乗除算命令がないため、自分で実装する必要があります。任意の値の乗除算は専用ルーチンが必要ですが、定数乗算および 2 のべき乗での除算はシフト命令を使って行えます。  

例えば、A に 5 を掛けるには以下のようにします:  

; 作業用変数に A の値をコピー
sta $00
; A <<= 2, つまり A *= 4
asl
asl
; 元の値を加える。これで A は元の値の 5 倍となる
clc
adc $00
符号なし数 A を 8 で割るには以下のようにします:

; A >>= 3, つまり A /= 8
lsr
lsr
lsr
16bit 数などの場合はローテート命令を併用した多倍長シフトを行えばOK。

* 乗除算
任意の値の乗除算には専用ルーチンが必要です。といっても、内容的には小学校で習う筆算を 2 進数で行うだけです(私が見た範囲ではどのゲームも同じような実装になっています)。  

例えば、4bit * 4bit の符号なし乗算は以下のように筆算できます:  

    1001
  * 1011
    ----
    1001
   1001
 1001
 -------
 1100011
これをルーチン化した例を示します (8bit * 8bit -> 16bit 符号なし乗算):

; 符号なし乗算 (8bit * 8bit -> 16bit)
;
; In
;   $0300       U8      左辺
;   $0301       U8      右辺
; Out
;   $0302       U16     結果 ($00 * $01, リトルエンディアン)
;
; $00: 作業用変数 (16bit, リトルエンディアン)
; $02: 作業用変数 (8bit)
mul_u8_u8_u16:
        ; 結果 (result) を 0 で初期化
        lda #0
        sta $0302
        sta $0303

        ; 左辺を 16bit 変数 $00 に代入 (lhs_tmp)
        lda $0300
        sta $00
        lda #0
        sta $01

        ; 右辺を 8bit 変数 $02 に代入 (rhs_tmp)
        lda $0301
        sta $02

        ; 右辺の各ビットを見ていき、1 なら加算を行う要領
        ; 擬似コードにすると以下のような感じ
        ;
        ; for(X = 8; X != 0; --X)
        ;   C = rhs_tmp & 1
        ;   rhs_tmp >>= 1
        ;   if(C)
        ;     result += lhs_tmp # 16bit
        ;   lhs_tmp <<= 1 # 16bit
        ldx #8
@loop:
        lsr $02
        bcc @loop_next
        lda $0302 ; 多倍長加算
        clc
        adc $00
        sta $0302
        lda $0303
        adc $01
        sta $0303
@loop_next:
        asl $00 ; 多倍長シフト
        rol $01
        dex
        bne @loop

        rts
除算も考え方自体は同様なので省略。慣れればなんとなく乗除算っぽいコードは見当がつくので、詳しく読む前にいったんデバッガでブレークを仕掛けて、"Step Out" でルーチン終了まで実行させ、期待通りの結果になっているかメモリビューアでチェックする、というのが手っ取り早いかもしれません。  

## BIT命令
BIT 命令でビットテストを行えます。レジスタを破壊せずに値を読めるので VBLANK 待ちなどでたまに使われますが、使用頻度は低いです。  
BIT 命令は N, V, Z フラグを書き換えます:  

N: 対象の bit7  
V: 対象の bit6  
Z: A と対象を and した結果が 0 であるか  

# linappleデバッグHowTo
1. F7でデバッガに切り替わる
2. bpxコマンドでアドレス指定でブレークポイントを設定できる
3. spaceキーでステップ実行、SHIFT+spaceでステップアウト、Ctrl+spaceでトレースオーバー
4. bplでブレイクポイント一覧を画面に表示できる
5. m1 [16進数アドレス]でメモリダンプを出力できる。コード画面に戻るときは[code]
